#!/usr/bin/python

# Correa, C.A., Marulanda, G., Garces, A. Optimal Microgrid Management in the
# Colombian Energy Market with Demand Response and Energy Storage
# Microgrid simulation
from gurobipy import *
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import datetime

# Function for reading data from simple example data
def readExampleData():
    data = pd.read_csv("DemandayPV24DRGEO.csv") 
    Pl = list(data.get("dem"))
    Ps = list(data.get("PV"))
    return Pl, Ps

# Function for reading load data from loadMeasures dataset
# Data available from 03/01/2017 to 21/12/2017
# date: selects the day for reading the data
# id: selects the location (house number) for the load measurements
def readLoadPVData(date,id):
    # Reads complete load dataset
    loadData = pd.read_csv("loadMeasures.csv", sep=',', index_col="datetime", parse_dates=True)
    # Gets load data for a particular date and id
    Pl = list(loadData.loc[date.strftime("%Y-%m-%d"),id])
    # Gets load data for all the year and a particular id
    yearLoadData = loadData.loc[date.strftime("%Y")+'-01-01':date.strftime("%Y")+'-12-31',id]

    # Reads complete PV dataset
    pvData = pd.read_csv("PVforecast-measure.csv", sep=',', index_col="datetime", parse_dates=True)
    # Gets PV data for a particular date
    Ppv = list(pvData.loc[date.strftime("%Y-%m-%d"),"PV forecast [kW]"])
    # Gets PV data for all the year
    yearPvData = pvData.loc[date.strftime("%Y")+'-01-01':date.strftime("%Y")+'-12-31','PV forecast [kW]']

    # Joins the complete load and PV yearly data as a single dataframe
    yearLoadPvData = yearPvData.to_frame().join(yearLoadData.to_frame())
    # Computes the average net power flow
    yearPn = abs(yearLoadPvData["PV forecast [kW]"] - yearLoadPvData[id])
    Pnmean = yearPn.mean()
    Pn = list(yearPn.loc[date.strftime("%Y-%m-%d")])

    return Pl, Ppv, Pn, Pnmean

# Function for computing the energy price according to Creg 15-2018
def computeCregPrice():
    # Defines the typical load curve
    Curvapu=0.01*np.array([60,65,70,70,75,80,80,80,80,80,75,75,75,80,85,90,90,95,100,100,95,85,80,65])
    fch=2

    # Finds the intervals for maximum (x), medium (z) and minimum (y) load
    indx = np.where((Curvapu > 0.95))[0]
    indz = np.where((Curvapu > 0.75) & (Curvapu <= 0.95))[0]
    indy = np.where((Curvapu < 0.75))[0]
    Hx=len(indx)
    Hz=len(indz)
    Hy=len(indy)
    Px=np.mean(Curvapu[indx])
    Pz=np.mean(Curvapu[indz])
    Py=np.mean(Curvapu[indy])
    Dt=550
    sumPi=np.sum(Curvapu)

    # Builds the matrices
    A=np.array([[Hx*Px/fch,Hz*Pz,fch*Hy*Py],[1/fch,-Px/Pz,0],[1/(fch*fch),0,-Px/Py]])
    b=np.array([[Dt*sumPi],[0],[0]])

    # Solves the linear system 
    x = np.linalg.solve(A, b)

    # CostoVariable=np.sum(x[0]*Curvapu[indx])+np.sum(x[1]*Curvapu[indz])+np.sum(x[2]*Curvapu[indy])
    # CostoFija=np.sum(Dt*Curvapu)

    Cd = np.zeros(24)
    Cd[indx] = x[0]
    Cd[indz] = x[1]
    Cd[indy] = x[2]
    return list(Cd)


# Date for load and PV data
# Data available from 03/01/2017 to 21/12/2017
loadDate = datetime.date(2017,3,2)
# Date for historical market price
# Data available from 
priceDate = datetime.date(2019,3,2)
useHistoricPrice = True
useDynamicPrice = False
useCregPrice = False
useHistoricLoadPV = True

# Loads suplied and consumed power data from csv file:
# Pl: power consumed by the loads
# Ps: power generated by the photovoltaic system
# Pn: average net power load
if useHistoricLoadPV:
    Pl, Ps, Pn, Pnmean = readLoadPVData(loadDate,'59')
else:
    Pl, Ps = readExampleData()

if useHistoricPrice:
    # Loads market price data from csv file:
    # Cd: energy cost
    data = pd.read_csv("precioBolsa.csv")
    data.set_index("Fecha", inplace=True)
    # Gets the hourly market price for a given date
    Cd = list(data.loc[priceDate.strftime("%Y-%m-%d"), :])
elif useCregPrice:
    Cd = computeCregPrice()
elif useDynamicPrice:
    # Loads market price data from csv file:
    # Cd: energy cost
    data = pd.read_csv("precioBolsa.csv")
    data.set_index("Fecha", inplace=True)
    # Gets the hourly market price for a given date
    Cm = list(data.loc[priceDate.strftime("%Y-%m-%d"), :])
    # Computes the daily mean for the complete dataset and stores it
    # as the last column of the dataframe
    data['dailymean'] = data.mean(axis=1)
    # Computes the mean market price for all the year
    Cmmean = data.loc[priceDate.strftime("%Y")+'-01-01':priceDate.strftime("%Y")+'-12-31','dailymean'].mean()
    Cu = 550   # Unit energy cost
    Cd = list((Cu/2)*(Cm/Cmmean + Pn/Pnmean))

# Create a new moded
m = Model('microgrid')

# Create paremeters
Pbat_nom = 20               # Nominal battery power
eta_ch = 0.95               # Charge efficiency
eta_dch = 0.95              # Discharge efficiency
Pd_min = 0                  # Minimum power supplied by the grid
Pd_max = 50                 # Maximum power supplied by the grid
Pch_min = 0                 # Minimum power charged to the batteries
Pch_max = 20                # Maximum power charged to the batteries
Pdch_min = 0                # Minimum power discharged from the batteries
Pdch_max = 20               # Maximum power discharged from the batteries
Ee_min = 0.2*Pbat_nom*5     # Minimum energy stored in the batteries
Ee_max = 0.8*Pbat_nom*5     # Maximum energy stored in the batteries

# Create variables
Pd   = m.addVars(range(24),             lb=Pd_min,                name='PowerSupplyGrid')           # Power supplied by the grid at time t
Pch  = m.addVars(range(24),             lb=Pch_min,  ub=Pch_max,  name='PowerChargeBatteries')      # Power charged to the batteries at time t
Pdch = m.addVars(range(24),             lb=Pdch_min, ub=Pdch_max, name='PowerDirchargeBatteries')   # Power discharged from the batteries at time t
Ee   = m.addVars(range(24),             lb=Ee_min,   ub=Ee_max,   name='EnergyStoreBatteries')      # Energy stored in the batteries at time t

# Create constraints
m.addConstrs((Ee[t] == Ee[t-1] + eta_ch*Pch[t-1] - eta_dch * Pdch[t-1] for t in range(1,24)), name="Constr2")
m.addConstrs((Pd[t] == Pl[t] + Pch[t] - Pdch[t] - Ps[t] for t in range(24)), name="Constr3")
m.addConstr(Ee[0] == Ee[23], name="Constr5")
m.addConstrs((Pd[t] <= Pl[t] for t in range(24)), name="Constr9")

# Create objective function
m.setObjective(quicksum(Cd[t]*Pd[t] for t in range(24)), GRB.MINIMIZE)

# Save model
m.update()
# m.write('microgrid.lp')

# Run the optimizer
m.optimize()

# Get solution
if m.status == GRB.Status.OPTIMAL:
    Pd_sol = m.getAttr('x', Pd)
    Pch_sol = m.getAttr('x', Pch)
    Pdch_sol = m.getAttr('x', Pdch)
    Ee_sol = m.getAttr('x', Ee)

    # Appends the last value to show the last hour in the step plot
    Pd_res   = Pd_sol.values()   + [Pd_sol.values()[-1]]
    Pch_res  = Pch_sol.values()  + [Pch_sol.values()[-1]]
    Pdch_res = Pdch_sol.values() + [Pdch_sol.values()[-1]]
    Ee_res   = Ee_sol.values()   + [Ee_sol.values()[-1]]

    totalCost = m.objVal
    print(f"Price Date: {priceDate}, Load Date: {loadDate}, Total Energy Cost = ${totalCost:.2f}")
   
    fig, axs = plt.subplots(4, 1, constrained_layout=True, figsize=(10,13))
    figtitle = f"Price Date: {priceDate}, Load Date: {loadDate}, Total Energy Cost = ${totalCost:.2f}"
    
    if useHistoricPrice:
        figtitle = figtitle + ", Market Price"
    elif useCregPrice:
        figtitle = figtitle + ", CREG Price"
    elif useDynamicPrice:
        figtitle = figtitle + ", Dynamic Price"
    fig.suptitle(figtitle)
    axs[0].step(range(25),Cd + [Cd[-1]], where='post')
    axs[0].legend(["Spot price of Grid Power (Pd)"])
    axs[0].minorticks_on()
    axs[0].grid(b=True, which='major', color='darkgray', linestyle='-')
    axs[0].grid(b=True, which='minor', color='lightgray', linestyle='--')
    axs[1].step(range(25),Pd_res, where='post', linestyle='-')
    axs[1].step(range(25),Ps + [Ps[-1]], where='post', linestyle='--')
    axs[1].step(range(25),Pl + [Pl[-1]], where='post', linestyle='--')
    axs[1].legend(["Power supplied by the grid (Pd)", "Power supplied by the PV system (Ps)", "Power consumed by the loads (Pl)"])
    axs[1].minorticks_on()
    axs[1].grid(b=True, which='major', color='darkgray', linestyle='-')
    axs[1].grid(b=True, which='minor', color='lightgray', linestyle='--')
    axs[2].step(range(25),Pch_res, where='post', linestyle='-')
    axs[2].step(range(25),Pdch_res, where='post', linestyle='--')
    axs[2].legend(["Charge Power in battery (Pch)", "Discharge Power in battery (Pdch)"])
    axs[2].minorticks_on()
    axs[2].grid(b=True, which='major', color='darkgray', linestyle='-')
    axs[2].grid(b=True, which='minor', color='lightgray', linestyle='--')
    axs[3].plot(range(25),Ee_res, linestyle='-')
    axs[3].legend(["Energy in battery (Ee)"])
    axs[3].minorticks_on()
    axs[3].grid(b=True, which='major', color='darkgray', linestyle='-')
    axs[3].grid(b=True, which='minor', color='lightgray', linestyle='--')

    # Export data to csv file
    hours = [datetime.time(h).strftime("%H:%M") for h in range(24)]
    table = pd.DataFrame({"H":hours,"Pch":Pch_res[:-1],"Pdch":Pdch_res[:-1],"Pd":Pd_res[:-1]})
    table.to_csv('result.csv', index=False, sep=';', line_terminator=';\n')

    filename = "OptimalSolution_" + priceDate.strftime("%Y-%m-%d")
    if useHistoricPrice:
        filename = filename + "_HistoricPrice.svg"
    elif useCregPrice:
        filename = filename + "_CregPrice.svg"
    elif useDynamicPrice:
        filename = filename + "_DynamicPrice.svg"
    plt.savefig("results/" + filename)
   
    plt.show()
    print("Optimization finished!")
else:
    m.computeIIS()
    if m.IISMinimal:
        print('IIS is minimal\n')
    else:
        print('IIS is not minimal\n')
    print('The following constraint(s) cannot be satisfied:')
    for c in m.getConstrs():
        if c.IISConstr:
            print('%s' % c.constrName)